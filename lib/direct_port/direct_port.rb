require 'yaml'
require 'digest/md5'

##
# Module VBoxDirectPorts
# It add ports forwarding in VirtualBox VM
# It can generate ports based upon hostname
#
# Configuration files.
# (.dist) means there is should be distributive file by default with default configuration
#
# - pf-config.yml(.dist)
#   This file contains custom user configuration. E.g.:
#     my.hostname.cc:
#     - host_ip: 127.0.0.1
#       guest_ip: 0.0.0.0
#       host: 80
#       guest: 80
#
# - pf-hosts
#   This file contains user hostnames.
#   System will generate guest ports and host IP addresses for them in
#   file pf-config-autogenerated.yml.
#   Default guest IP address is 0.0.0.0
#
# - pf-ports(.dist)
#   Ports list which will be used on the host side during autogeneration.
#   Guest ports will be generated automatically.
#
# Guest ports generation algorithm in
#     Vagrant::VBoxDirectPorts::host_ports
# Host IP addresses generation algorithm in
#     Vagrant::VBoxDirectPorts::host_ip
#
# Using in Vagrantfile:
#     # Set up port forwarding in non-provisioning mode
#     # http://stackoverflow.com/questions/24855635/check-if-vagrant-provisioning-has-been-done
#     if File.file?('.vagrant/machines/default/virtualbox/action_provision')
#       require_relative 'vbox_direct_ports.rb'
#
#       # Verbosity status
#       # Vagrant::VBoxDirectPorts::verbosity = false
#       # Generate always new file pf-config-autogenerated.yml (any vagrant command here)
#       # Vagrant::VBoxDirectPorts::always_generate_config = false
#       # Set direct_vm_update to update port forwarding list with using Vagrant native functionality
#       # Vagrant::VBoxDirectPorts::direct_vm_update = true
#       # Updated hosts status
#       # Vagrant::VBoxDirectPorts::update_hosts = true
#
#       # Make ports forwarding
#       Vagrant::VBoxDirectPorts::forward_ports config
#     end
#
# GitHub Gist: https://gist.github.com/andkirby/dd66d8fadcd8050b381a1cfd2a5f801e
#
module Vagrant
  module VBoxDirectPorts
    module_function

    # region Properties
    ##
    # Enable verbosity
    #
    @@verbosity = false

    ##
    # Status applying forward ports config files
    #
    @@apply_forward_ports = true

    ##
    # Generate config always in file pf-config-autogenerated.yml
    #
    @@always_generate_config = false

    ##
    # Status of updating port forwarding list in VirtualBox VM directly
    #
    @@direct_update = true

    ##
    # Status of updating hosts file
    #
    @@update_hosts = true

    ##
    # Set status of output
    #
    def verbosity=(flag)
      @@verbosity = flag
    end

    ##
    # Set status of output
    #
    def always_generate_config=(flag)
      @@always_generate_config = flag
    end

    ##
    # Status of updating port forwarding list in VirtualBox VM directly
    # If FALSE it will use Vagrant functionality
    #
    def direct_vm_update=(flag)
      @@direct_update = flag
    end

    ##
    # Set status of updating hosts file
    #
    def update_hosts=(flag)
      @@update_hosts = flag
    end

    ##
    # Set status applying forward ports config files
    #
    def apply_forward_ports=(flag)
      @@apply_forward_ports = flag
    end
    # endregion

    ##
    # Initialize port forwarding
    #
    # If system is provisioned it will make ports forwarding
    # or it will initiate hostname for the system etc/hosts according to pf-config.yml
    #
    def initialize(config)
      if provisioned?
        # Make ports forwarding
        # Don't run it at first load, in provisioning mode
        forward_ports config
      else
        # on first load initialize hostnames and IP addresses in the system etc/hosts file from pf-config.yml(.dist)
        generate_flag = @@apply_forward_ports
        @@apply_forward_ports = false
        forward_custom_ports config
        @@apply_forward_ports = generate_flag
      end

      self
    end

    # region Main methods
    ##
    # Set up port forwarding from configuration file
    #
    # pf-config.yml or pf-config.yml.dist
    #
    def forward_ports(config)
      forward_hosts_ports config
      forward_custom_ports config
    end

    ##
    # Check if VM is provisioned
    #
    def provisioned?
      # http://stackoverflow.com/questions/24855635/check-if-vagrant-provisioning-has-been-done
      File.file?('.vagrant/machines/default/virtualbox/action_provision')
    end

    ##
    # Forward ports by user config file
    #
    def forward_custom_ports(config)
      update_hosts_file load_config(port_forward_custom_file) if @@update_hosts

      apply_forward_ports_config config, file: port_forward_custom_file

      self
    end

    ##
    # Forward ports by user config file
    #
    def show_forwarded_ports(format: 'plain')
      unless @@apply_forward_ports
        puts 'Port forwarding is disabled.'.red
      end

      file = port_forward_custom_file
      puts "File #{file}."
      config = load_config(file)
      show_config_forwarding(config)

      self
    end

    ##
    # Forward host ports from file pf-hosts (or pf-hosts.dist)
    #
    def forward_hosts_ports(config)
      return self unless can_generate_ports?

      unless generate_ports?
        apply_forward_ports_config config, file: autogenerated_config_file
        return self
      end

      generated_config = {}

      (File.read(hostnames_file) + $/).each_line do |line|
        hostname = line.strip!
        # Ignore comments, empty strings
        next if hostname == nil || hostname == '' || hostname.chars[0] == '#'

        generated_config[hostname] = auto_forward_ports_config(hostname: hostname, config: config)
      end

      # Generate ports forwarding from written file
      apply_forward_ports_config config, file: write_autogenerated_config(generated_config)

      set_state_timestamp

      update_hosts_file generated_config if @@update_hosts

      self
    end

    # endregion

    protected
    module_function

    ##
    # It will return path to pf-config.yml if exist
    # or pf-config.yml.dist instead
    #
    def port_forward_custom_file
      path = current_dir

      path + '/pf-config.yml' +
          (File.exist?(path + '/pf-config.yml') ? '' : '.dist')
    end

    # region Ports Auto-generation

    ##
    # Check if it's needed to generate ports
    #
    def generate_ports?
      return true if @@always_generate_config

      !File.exist?(autogenerated_config_file) || hostnames_changed?
    end

    ##
    # Check if required for generating ports files are exist
    #
    def can_generate_ports?
      File.exist?(hostnames_file) && File.readable?(hostnames_file) &&
          File.exist?(ports_file) && File.readable?(ports_file)
    end

    ##
    # Check if pf-hosts file got changes
    #
    def hostnames_changed?
      File.exist?(hostnames_file + '.ctime') &&
          File.exist?(hostnames_file) &&
          File.ctime(hostnames_file) != File.read(hostnames_file + '.ctime')
    end

    ##
    # Get path to file with hostnames list
    #
    def hostnames_file
      current_dir + '/pf-hosts'
    end

    ##
    # Write config into YAML file
    #
    def write_autogenerated_config(ports_config)
      file = autogenerated_config_file
      fw = File.open(file, 'w')
      fw.write(ports_config.to_yaml)
      fw.close

      file
    end

    ##
    # Update ctime of pf-hosts file
    #
    def set_state_timestamp
      fw = File.open(hostnames_file + '.ctime', 'w')
      fw.write(File.ctime hostnames_file)
      fw.close
    end

    ##
    # Get path to automatically generate network config file
    #
    def autogenerated_config_file
      current_dir + '/pf-config-autogenerated.yml'
    end

    ##
    # Generate configuration automatically with guest ports and host IP address for a hostname
    #
    def auto_forward_ports_config(hostname:, config:)
      configs = []
      ip_host = host_ip(hostname)
      host_ports(hostname).each { |host_port, guest_port|
        configs << {
            host: host_port, guest: guest_port,
            host_ip: ip_host, guest_ip: default_guest_ip
        }
      }

      configs
    end

    ##
    # Get hostname ports map which should be forwarded from a host OS to a guest OS
    #
    def host_ports(hostname)
      base_port = guest_base_port(hostname).to_i
      ports_map = {}
      file = ports_file

      index = 0
      File.open(file, 'r') do |f|
        f.each_line do |port|
          # Ignore comments, empty strings
          next if port == nil || port.chars[0] == '#'

          ports_map[port.to_i] = base_port + port.to_i

          index += 1
        end
      end

      # Bash script example with the same algorithm
=begin
      # Generate ports for hostname
      base_port=$(( 1024 + $(printf %x ${hash:0:2}) \
        + $(printf %x ${hash:2:4}) + $(printf %x ${hash:4:6}) ))
      host_port_80=$(( ${base_port} + 80 ))
      host_port_443=$(( ${base_port} + 443 ))
      host_port_3306=$(( ${base_port} + 3306 ))
=end

      ports_map
    end

    ##
    # Get path to file with ports list
    #
    def ports_file
      path = current_dir
      path + '/pf-ports' + (File.exist?(path + '/pf-ports') ? '' : '.dist')
    end

    ##
    # Generate guest base port based upon a hostname
    #
    # NOTE: This algorithm must reflected in magento2-nginx-redis-php/create-container.sh file
    # or used the same container ports
    #
    def guest_base_port(hostname)
      hash = Digest::SHA1.hexdigest hostname
      1024 + hash[0..1].to_i(16) + hash[2..3].to_i(16) + hash[4..5].to_i(16)
    end

    ##
    # Generate local IP address based upon a hostname
    #
    def host_ip(hostname)
      hash = Digest::SHA1.hexdigest hostname
      sprintf('127.%d.%d.%d', hash[0..1].to_i(16), hash[2..3].to_i(16), hash[4..5].to_i(16))
    end

    # endregion

    # region Apply ports forwarding by YAML file

    ##
    # Forward ports by config file
    #
    def apply_forward_ports_config(config, file:)
      return unless @@apply_forward_ports

      file_config = load_config(file)

      show_config_forwarding file_config if @@verbosity

      file_config.each { | group_key, group_net_conf |
        group_net_conf.each { |net_conf|
          # convert keys to hash keys
          net_conf_hashed = Hash.new
          net_conf.each { |key, value| net_conf_hashed[key.to_sym] = value }

          if @@direct_update
            ##
            # Due to reason there is no ability to use the same ports Vagrant command "config.vm.network" cannot be used
            # https://github.com/mitchellh/vagrant/issues/7905
            #
            add_vbox_nat_port_forwarding(config, net_conf_hashed)
          else
            # Add port forwarding via Vagrant
            config.vm.network 'forwarded_port', net_conf_hashed
          end
        }
      }
    end

    ##
    # Show port forwarding information from config
    #
    def show_config_forwarding(config)
      config.each { |group_key, group_net_conf|
        puts "===== #{group_key.green} ====="
        group_net_conf.each { |net_conf|
          # convert keys to hash keys
          net_conf_hashed = Hash.new
          net_conf.each { |key, value| net_conf_hashed[key.to_sym] = value }

          printf('%15s:%-5s => %' +
                     (net_conf_hashed[:guest_ip] ? net_conf_hashed[:guest_ip].length.to_s : '1') +
                     's:%-5s' + "\n",
                 net_conf_hashed[:host_ip],
                 net_conf_hashed[:host],
                 net_conf_hashed[:guest_ip],
                 net_conf_hashed[:guest])
        }
        puts '=' * (12 + group_key.length)
      }
    end

    ##
    # Make direct changes in VM
    # It works with NAT only
    #
    def add_vbox_nat_port_forwarding(config, host:, guest:, host_ip: '', guest_ip: '')
      config.vm.provider :virtualbox do |vb|
        value = "tcp,#{host_ip},#{host},#{guest_ip},#{guest}"
        value = Digest::SHA1.hexdigest(value) + ',' + value # add unique ID
        vb.customize ['modifyvm', :id, '--natpf1', value]
      end
    end

    ##
    # Load YAML configuration
    #
    def load_config(file)
      YAML.load_file(file) || {}
    end
    # endregion

    # region Common

    ##
    # Get current directory path
    #
    def current_dir
      File.dirname(File.expand_path(__FILE__))
    end

    ##
    # Default guest IP address
    #
    def default_guest_ip
      '0.0.0.0'
    end

    ##
    # It will make numbers lower
    # because there is the range 0..9 and a..f
    # The smallest number is 48 ("0".ord)
    #
    def hash_symbol_int(char)
      char.ord - 47 # 47 means "0".ord - 1
    end

    ##
    # Added records in system etc/hosts file
    #
    def update_hosts_file(config)
      unless File.writable? system_hosts_file
        puts "Cannot update system etc/hosts file. It's not writable".red if @@verbosity
        return
      end

      hosts_content = File.read(system_hosts_file).strip
      updated = false
      hosts_entries = []
      config.each { |hostname, item|
        next if item[0][:host_ip].nil? && item[0]['host_ip'].nil?

        host_ip = item[0][:host_ip] || item[0]['host_ip']

        # 20 symbols space for IP address
        entry = host_ip + ' ' * (20 - host_ip.length) + hostname

        # ignore exist entries
        if hosts_content.scan(/^#{host_ip}[ \t]+#{hostname}$/).empty?
          if hosts_content.scan(/^(\d{1,3}\.?){4}[ \t]+#{hostname}$/).empty?
            hosts_content += $/ + entry
          else
            hosts_content = hosts_content.gsub!(/^(\d{1,3}\.?){4}[ \t]+#{hostname}$/, entry)
          end
          updated = true
          hosts_entries << entry
        end
      }
      begin
        # Apply changed hosts file content
        if updated
          fw = File.open(system_hosts_file, 'w')
          fw.write hosts_content + $/
          fw.close
          puts 'System etc/hosts file has been updated.'.yellow
        end
      rescue Errno::EACCES
        puts 'Unable to update system etc/hosts file. Permission denied.'.red
        puts 'Please add following content into etc/hosts file manually:'.yellow
        hosts_entries.each { |item| puts "#{item}"}
        puts '#==== end ===='.yellow
      end
    end

    ##
    # Get path to hosts file
    #
    def system_hosts_file
      ENV['OS'] == 'Windows_NT' ? 'c:/Windows/System32/drivers/etc/hosts' : '/etc/hosts'
    end

    #endregion
  end
end

# String colorization
class String
  # colorization
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end

  def red
    colorize(31)
  end

  def green
    colorize(32)
  end

  def yellow
    colorize(33)
  end

  def blue
    colorize(34)
  end

  def pink
    colorize(35)
  end

  def light_blue
    colorize(36)
  end
end
